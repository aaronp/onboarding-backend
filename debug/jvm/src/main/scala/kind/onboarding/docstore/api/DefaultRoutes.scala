//> using scala "3.3.1"
//> using lib "com.lihaoyi::cask:0.8.3"
//> using lib "com.lihaoyi::scalatags:0.12.0"
/** Document Storage API API for storing, retrieving, updating, and deleting JSON documents.
  *
  * OpenAPI spec version: 1.1.0
  *
  * Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator.
  *
  * https://openapi-generator.tech
  */

// this is generated from apiRoutes.mustache
package kind.onboarding.docstore.api

import kind.onboarding.docstore.model.*

import upickle.default.{ReadWriter => RW, macroRW}
import upickle.default.*

import kind.onboarding.docstore.model.CompareDocuments200Response
import kind.onboarding.docstore.model.CompareDocuments400Response
import kind.onboarding.docstore.model.CompareDocumentsRequest
import kind.onboarding.docstore.model.CopyDocument200Response
import kind.onboarding.docstore.model.CopyDocument404Response
import kind.onboarding.docstore.model.CopyDocumentRequest
import kind.onboarding.docstore.model.DeleteDocument200Response
import kind.onboarding.docstore.model.GetDocument404Response
import kind.onboarding.docstore.model.GetMetadata200Response
import kind.onboarding.docstore.model.SaveDocument200Response
import kind.onboarding.docstore.model.UpdateDocument200Response
import ujson.Value

class DefaultRoutes(service: DefaultService) extends cask.Routes {

  /** Compare two JSON documents
    */
  @cask.post("/diff")
  def compareDocuments(request: cask.Request) = {

    def failFast = request.queryParams.keySet.contains("failFast")

    val result = for {
      compareDocumentsRequestData <- Parsed
        .eval(CompareDocumentsRequestData.fromJsonString(request.bodyAsString))
        .mapError(e =>
          s"Error parsing json as CompareDocumentsRequest from >${request.bodyAsString}< : ${e}"
        ) /* not array or map */
      compareDocumentsRequest <- Parsed.fromTry(compareDocumentsRequestData.validated(failFast))
      result                  <- Parsed.eval(service.compareDocuments(compareDocumentsRequest))
    } yield result

    result match {
      case Left(error) => cask.Response(error, 500)
      case Right(value: CompareDocuments200Response) =>
        cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
      case Right(value: CompareDocuments400Response) =>
        cask.Response(data = write(value), 400, headers = Seq("Content-Type" -> "application/json"))
      case Right(other) => cask.Response(s"$other", 200)
    }
  }

  /** Copy JSON data from one path to another
    */
  @cask.post("/copy")
  def copyDocument(request: cask.Request) = {

    def failFast = request.queryParams.keySet.contains("failFast")

    val result = for {
      copyDocumentRequestData <- Parsed
        .eval(CopyDocumentRequestData.fromJsonString(request.bodyAsString))
        .mapError(e =>
          s"Error parsing json as CopyDocumentRequest from >${request.bodyAsString}< : ${e}"
        ) /* not array or map */
      copyDocumentRequest <- Parsed.fromTry(copyDocumentRequestData.validated(failFast))
      result              <- Parsed.eval(service.copyDocument(copyDocumentRequest))
    } yield result

    result match {
      case Left(error) => cask.Response(error, 500)
      case Right(value: CopyDocument200Response) =>
        cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
      case Right(value: CopyDocument404Response) =>
        cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
      case Right(other) => cask.Response(s"$other", 200)
    }
  }

  /** Delete JSON data at a specified path
    */
  @cask.delete("/doc/:path")
  def deleteDocument(path: String, request: cask.Request) = {

    def failFast = request.queryParams.keySet.contains("failFast")

    val result = for {
      path   <- Parsed(path)
      result <- Parsed.eval(service.deleteDocument(path))
    } yield result

    result match {
      case Left(error) => cask.Response(error, 500)
      case Right(value: DeleteDocument200Response) =>
        cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
      case Right(value: GetDocument404Response) =>
        cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
      case Right(other) => cask.Response(s"$other", 200)
    }
  }

  /** Retrieve JSON data from a specified path
    */
  @cask.get("/doc/:path")
  def getDocument(path: String, request: cask.Request, version: Option[String]) = {

    def failFast = request.queryParams.keySet.contains("failFast")

    val result = for {
      path   <- Parsed(path)
      result <- Parsed.eval(service.getDocument(path, version))
    } yield result

    result match {
      case Left(error) => cask.Response(error, 500)
      case Right(value: Value) =>
        cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
      case Right(value: GetDocument404Response) =>
        cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
      case Right(other) => cask.Response(s"$other", 200)
    }
  }

  /** Retrieve metadata information
    */
  @cask.get("/metadata/:path")
  def getMetadata(path: String, request: cask.Request) = {

    def failFast = request.queryParams.keySet.contains("failFast")

    val result = for {
      path   <- Parsed(path)
      result <- Parsed.eval(service.getMetadata(path))
    } yield result

    result match {
      case Left(error) => cask.Response(error, 500)
      case Right(value: GetMetadata200Response) =>
        cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
      case Right(other) => cask.Response(s"$other", 200)
    }
  }

  /** Save JSON data to a specified path
    */
  @cask.post("/doc/:path")
  def saveDocument(path: String, request: cask.Request) = {

    def failFast = request.queryParams.keySet.contains("failFast")

    val result = for {
      path <- Parsed(path)
      body <- Parsed
        .eval(read[Map[String, Value]](request.bodyAsString))
        .mapError(e =>
          s"Error parsing json as a string map of Value from >${request.bodyAsString}< : ${e}"
        ) /* not x-deserialize-asModelMap */
      result <- Parsed.eval(service.saveDocument(path, body))
    } yield result

    result match {
      case Left(error) => cask.Response(error, 500)
      case Right(value: SaveDocument200Response) =>
        cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
      case Right(other) => cask.Response(s"$other", 200)
    }
  }

  /** Update JSON data at a specified path
    */
  @cask.patch("/doc/:path")
  def updateDocument(path: String, request: cask.Request) = {

    def failFast = request.queryParams.keySet.contains("failFast")

    val result = for {
      path <- Parsed(path)
      body <- Parsed
        .eval(read[Map[String, Value]](request.bodyAsString))
        .mapError(e =>
          s"Error parsing json as a string map of Value from >${request.bodyAsString}< : ${e}"
        ) /* not x-deserialize-asModelMap */
      result <- Parsed.eval(service.updateDocument(path, body))
    } yield result

    result match {
      case Left(error) => cask.Response(error, 500)
      case Right(value: UpdateDocument200Response) =>
        cask.Response(data = write(value), 200, headers = Seq("Content-Type" -> "application/json"))
      case Right(value: GetDocument404Response) =>
        cask.Response(data = write(value), 404, headers = Seq("Content-Type" -> "application/json"))
      case Right(other) => cask.Response(s"$other", 200)
    }
  }

  initialize()
}
